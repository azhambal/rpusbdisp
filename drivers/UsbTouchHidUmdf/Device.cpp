#include "Device.h"

#include <ntddk.h>
#include <initguid.h>

// Include USB transport driver IOCTLs
#include "../UsbTransportUmdf/UsbIoctl.h"

#include "Trace.h"
#include "Device.tmh"  // Auto-generated by WPP preprocessor

namespace
{
    NTSTATUS EnsureUsbTransportTarget(_In_ WDFDEVICE device)
    {
        auto* context = GetTouchContext(device);

        if (context->UsbTransportTarget != nullptr)
        {
            return STATUS_SUCCESS;
        }

        TRACE_VERBOSE(TRACE_TOUCH, "Searching for USB transport device interface");

        // Find the USB transport driver device interface
        PWSTR symbolicLinkList = nullptr;
        NTSTATUS status = IoGetDeviceInterfaces(&GUID_DEVINTERFACE_RPUSB_TRANSPORT,
                                                nullptr,
                                                DEVICE_INTERFACE_ACTIVE,
                                                &symbolicLinkList);
        if (!NT_SUCCESS(status))
        {
            TRACE_ERROR(TRACE_TOUCH, "IoGetDeviceInterfaces failed: %!STATUS!", status);
            return status;
        }

        if (symbolicLinkList[0] == UNICODE_NULL)
        {
            TRACE_WARNING(TRACE_TOUCH, "USB transport device interface not found");
            ExFreePool(symbolicLinkList);
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        UNICODE_STRING targetName;
        RtlInitUnicodeString(&targetName, symbolicLinkList);

        TRACE_INFO(TRACE_TOUCH, "Opening USB transport target for touch data");

        status = WdfIoTargetCreate(device, WDF_NO_OBJECT_ATTRIBUTES, &context->UsbTransportTarget);
        if (NT_SUCCESS(status))
        {
            WDF_IO_TARGET_OPEN_PARAMS openParams;
            WDF_IO_TARGET_OPEN_PARAMS_INIT_OPEN_BY_NAME(&openParams, &targetName, GENERIC_READ | GENERIC_WRITE);
            openParams.ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
            openParams.CreateDisposition = FILE_OPEN;

            status = WdfIoTargetOpen(context->UsbTransportTarget, &openParams);
            if (!NT_SUCCESS(status))
            {
                TRACE_ERROR(TRACE_TOUCH, "WdfIoTargetOpen failed: %!STATUS!", status);
                WdfObjectDelete(context->UsbTransportTarget);
                context->UsbTransportTarget = nullptr;
            }
            else
            {
                TRACE_INFO(TRACE_TOUCH, "USB transport target opened successfully");
            }
        }
        else
        {
            TRACE_ERROR(TRACE_TOUCH, "WdfIoTargetCreate failed: %!STATUS!", status);
        }

        ExFreePool(symbolicLinkList);
        return status;
    }
}

NTSTATUS TouchDeviceCreate(_Inout_ PWDFDEVICE_INIT deviceInit)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);

    WdfDeviceInitSetDeviceType(deviceInit, FILE_DEVICE_UNKNOWN);
    WdfDeviceInitSetExclusive(deviceInit, FALSE);

    WDF_PNPPOWER_EVENT_CALLBACKS pnpCallbacks;
    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpCallbacks);
    WdfDeviceInitSetPnpPowerEventCallbacks(deviceInit, &pnpCallbacks);

    WDF_OBJECT_ATTRIBUTES attributes;
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&attributes, TouchDeviceContext);

    TRACE_INFO(TRACE_DEVICE, "Creating HID touch device");

    WDFDEVICE device;
    NTSTATUS status = WdfDeviceCreate(&deviceInit, &attributes, &device);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_DEVICE, "WdfDeviceCreate failed: %!STATUS!", status);
        return status;
    }

    TRACE_INFO(TRACE_DEVICE, "HID touch device created, setting up IOCTL queue");

    WDF_IO_QUEUE_CONFIG queueConfig;
    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&queueConfig, WdfIoQueueDispatchParallel);
    queueConfig.EvtIoInternalDeviceControl = TouchEvtInternalIoctl;

    status = WdfIoQueueCreate(device, &queueConfig, WDF_NO_OBJECT_ATTRIBUTES, nullptr);

    if (NT_SUCCESS(status))
    {
        TRACE_INFO(TRACE_DEVICE, "HID touch device initialized successfully");
    }
    else
    {
        TRACE_ERROR(TRACE_DEVICE, "WdfIoQueueCreate failed: %!STATUS!", status);
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DEVICE, status);
    return status;
}

VOID TouchEvtInternalIoctl(_In_ WDFQUEUE queue,
                           _In_ WDFREQUEST request,
                           _In_ size_t outputBufferLength,
                           _In_ size_t inputBufferLength,
                           _In_ ULONG ioControlCode)
{
    UNREFERENCED_PARAMETER(queue);
    NTSTATUS status = STATUS_NOT_SUPPORTED;

    TRACE_VERBOSE(TRACE_HID, "HID IOCTL received: 0x%08lX (InLen=%Iu, OutLen=%Iu)",
                  ioControlCode, inputBufferLength, outputBufferLength);

    switch (ioControlCode)
    {
    case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
    {
        TRACE_VERBOSE(TRACE_HID, "IOCTL_HID_GET_DEVICE_DESCRIPTOR");

        PHID_DESCRIPTOR descriptor;
        size_t length;
        status = WdfRequestRetrieveOutputBuffer(request, sizeof(HID_DESCRIPTOR), reinterpret_cast<PVOID*>(&descriptor), &length);
        if (NT_SUCCESS(status))
        {
            RtlZeroMemory(descriptor, sizeof(HID_DESCRIPTOR));
            descriptor->bLength = sizeof(HID_DESCRIPTOR);
            descriptor->bDescriptorType = HID_DESCRIPTOR_TYPE_HID;
            descriptor->bcdHID = HID_REVISION;
            descriptor->bNumDescriptors = 1;
            descriptor->DescriptorList[0].bReportType = HID_REPORT_DESCRIPTOR_TYPE;
            descriptor->DescriptorList[0].wReportLength = sizeof(g_RpTouchReportDescriptor);
            WdfRequestSetInformation(request, sizeof(HID_DESCRIPTOR));
            TRACE_INFO(TRACE_HID, "HID device descriptor returned (ReportDescriptorLength=%u)",
                       sizeof(g_RpTouchReportDescriptor));
        }
        else
        {
            TRACE_ERROR(TRACE_HID, "WdfRequestRetrieveOutputBuffer failed: %!STATUS!", status);
        }
        break;
    }
    case IOCTL_HID_GET_REPORT_DESCRIPTOR:
    {
        TRACE_VERBOSE(TRACE_HID, "IOCTL_HID_GET_REPORT_DESCRIPTOR");

        PVOID buffer = nullptr;
        size_t length = 0;
        status = WdfRequestRetrieveOutputBuffer(request, sizeof(g_RpTouchReportDescriptor), &buffer, &length);
        if (NT_SUCCESS(status))
        {
            RtlCopyMemory(buffer, g_RpTouchReportDescriptor, sizeof(g_RpTouchReportDescriptor));
            WdfRequestSetInformation(request, sizeof(g_RpTouchReportDescriptor));
            TRACE_INFO(TRACE_HID, "HID report descriptor returned (%u bytes)",
                       sizeof(g_RpTouchReportDescriptor));
        }
        else
        {
            TRACE_ERROR(TRACE_HID, "WdfRequestRetrieveOutputBuffer failed: %!STATUS!", status);
        }
        break;
    }
    case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
    {
        TRACE_VERBOSE(TRACE_HID, "IOCTL_HID_GET_DEVICE_ATTRIBUTES");

        PHID_DEVICE_ATTRIBUTES attributes = nullptr;
        status = WdfRequestRetrieveOutputBuffer(request, sizeof(HID_DEVICE_ATTRIBUTES), reinterpret_cast<PVOID*>(&attributes), nullptr);
        if (NT_SUCCESS(status))
        {
            attributes->Size = sizeof(HID_DEVICE_ATTRIBUTES);
            attributes->VendorID = 0x1FC9;
            attributes->ProductID = 0x0094;
            attributes->VersionNumber = 0x0001;
            WdfRequestSetInformation(request, sizeof(HID_DEVICE_ATTRIBUTES));
            TRACE_INFO(TRACE_HID, "HID device attributes returned (VID=0x%04X PID=0x%04X Ver=0x%04X)",
                       attributes->VendorID, attributes->ProductID, attributes->VersionNumber);
        }
        else
        {
            TRACE_ERROR(TRACE_HID, "WdfRequestRetrieveOutputBuffer failed: %!STATUS!", status);
        }
        break;
    }
    case IOCTL_HID_READ_REPORT:
    {
        TRACE_VERBOSE(TRACE_REPORT, "IOCTL_HID_READ_REPORT");

        WDFDEVICE device = WdfIoQueueGetDevice(queue);
        auto* context = GetTouchContext(device);

        // Ensure we have a connection to the USB transport driver
        status = EnsureUsbTransportTarget(device);
        if (!NT_SUCCESS(status))
        {
            TRACE_WARNING(TRACE_REPORT, "USB transport target not available: %!STATUS!", status);
            break;
        }

        // Get touch data from USB transport driver
        RPUSB_TOUCH_DATA touchData = {};
        WDF_MEMORY_DESCRIPTOR outputDesc;
        WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(&outputDesc, &touchData, sizeof(touchData));

        TRACE_VERBOSE(TRACE_REPORT, "Querying USB transport for touch data");

        status = WdfIoTargetSendIoctlSynchronously(context->UsbTransportTarget,
                                                   nullptr,
                                                   IOCTL_RPUSB_GET_TOUCH_DATA,
                                                   nullptr,
                                                   &outputDesc,
                                                   nullptr);

        if (!NT_SUCCESS(status) || touchData.ContactCount == 0)
        {
            // No touch data available, return an empty report
            TRACE_VERBOSE(TRACE_REPORT, "No touch data available (status=%!STATUS!, contacts=%u)",
                          status, touchData.ContactCount);

            HID_TOUCH_INPUT_REPORT* report = nullptr;
            size_t length = 0;
            status = WdfRequestRetrieveOutputBuffer(request, sizeof(HID_TOUCH_INPUT_REPORT), reinterpret_cast<PVOID*>(&report), &length);
            if (NT_SUCCESS(status))
            {
                RtlZeroMemory(report, sizeof(HID_TOUCH_INPUT_REPORT));
                report->ReportId = 1;
                report->ContactCount = 0;
                WdfRequestSetInformation(request, sizeof(HID_TOUCH_INPUT_REPORT));
                status = STATUS_SUCCESS;
            }
            break;
        }

        TRACE_VERBOSE(TRACE_REPORT, "Touch data received: ContactCount=%u", touchData.ContactCount);

        // Generate HID input report from touch data
        // For simplicity, we only report the first contact
        HID_TOUCH_INPUT_REPORT* report = nullptr;
        size_t length = 0;
        status = WdfRequestRetrieveOutputBuffer(request, sizeof(HID_TOUCH_INPUT_REPORT), reinterpret_cast<PVOID*>(&report), &length);
        if (NT_SUCCESS(status))
        {
            RtlZeroMemory(report, sizeof(HID_TOUCH_INPUT_REPORT));
            report->ReportId = 1;

            // Find the first active contact
            for (UINT32 i = 0; i < 2; ++i)
            {
                if (touchData.Contacts[i].TipSwitch || touchData.Contacts[i].InRange)
                {
                    report->TipSwitch = touchData.Contacts[i].TipSwitch;
                    report->InRange = touchData.Contacts[i].InRange;
                    report->ContactId = touchData.Contacts[i].ContactId;
                    report->X = touchData.Contacts[i].X;
                    report->Y = touchData.Contacts[i].Y;

                    TRACE_VERBOSE(TRACE_REPORT, "HID report generated: Contact=%u TipSwitch=%u InRange=%u X=%u Y=%u",
                                  report->ContactId, report->TipSwitch, report->InRange,
                                  report->X, report->Y);
                    break;
                }
            }

            report->ContactCount = touchData.ContactCount;
            WdfRequestSetInformation(request, sizeof(HID_TOUCH_INPUT_REPORT));
        }
        else
        {
            TRACE_ERROR(TRACE_REPORT, "WdfRequestRetrieveOutputBuffer failed: %!STATUS!", status);
        }
        break;
    }
    default:
        TRACE_WARNING(TRACE_HID, "Unsupported HID IOCTL: 0x%08lX", ioControlCode);
        status = STATUS_NOT_SUPPORTED;
        break;
    }

    TRACE_VERBOSE(TRACE_HID, "HID IOCTL completed: 0x%08lX -> %!STATUS!", ioControlCode, status);
    WdfRequestComplete(request, status);
}
