#include "Queue.h"

#include <usb.h>

#include "UsbIoctl.h"
#include "UsbProtocol.h"
#include "Trace.h"
#include "Queue.tmh"  // Auto-generated by WPP preprocessor

NTSTATUS QueueCreate(_In_ WDFDEVICE device)
{
    TRACE_FUNCTION_ENTRY(TRACE_QUEUE);

    WDF_IO_QUEUE_CONFIG queueConfig;
    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&queueConfig, WdfIoQueueDispatchParallel);
    queueConfig.EvtIoDeviceControl = UsbDeviceIoDeviceControl;

    NTSTATUS status = WdfIoQueueCreate(device, &queueConfig, WDF_NO_OBJECT_ATTRIBUTES, nullptr);

    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_QUEUE, "WdfIoQueueCreate failed: %!STATUS!", status);
    }
    else
    {
        TRACE_INFO(TRACE_QUEUE, "IOCTL queue created successfully");
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_QUEUE, status);
    return status;
}

static NTSTATUS SendVendorControl(_In_ DeviceContext* context,
                                  _In_ UINT8 request,
                                  _In_ UINT16 value,
                                  _In_reads_bytes_opt_(bufferLength) PVOID buffer,
                                  _In_ size_t bufferLength)
{
    if (!context->DeviceReady)
    {
        TRACE_WARNING(TRACE_USB, "Device not ready for vendor control request 0x%02X", request);
        return STATUS_DEVICE_NOT_READY;
    }

    WDF_MEMORY_DESCRIPTOR memoryDescriptor;
    WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(&memoryDescriptor, buffer, static_cast<ULONG>(bufferLength));

    WDF_USB_CONTROL_SETUP_PACKET packet;
    WDF_USB_CONTROL_SETUP_PACKET_INIT_VENDOR(&packet,
                                             BmRequestHostToDevice,
                                             BmRequestToDevice,
                                             request,
                                             value,
                                             0);

    TRACE_VERBOSE(TRACE_USB, "Sending vendor control: Request=0x%02X Value=0x%04X Length=%Iu",
                  request, value, bufferLength);

    NTSTATUS status = WdfUsbTargetDeviceSendControlTransferSynchronously(context->UsbDevice,
                                                                          nullptr,
                                                                          nullptr,
                                                                          &packet,
                                                                          bufferLength > 0 ? &memoryDescriptor : nullptr,
                                                                          nullptr);

    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_USB, "Vendor control request 0x%02X failed: %!STATUS!", request, status);
    }

    return status;
}

VOID UsbDeviceIoDeviceControl(_In_ WDFQUEUE queue,
                              _In_ WDFREQUEST request,
                              _In_ size_t outputBufferLength,
                              _In_ size_t inputBufferLength,
                              _In_ ULONG ioControlCode)
{
    auto device = WdfIoQueueGetDevice(queue);
    auto* context = GetDeviceContext(device);
    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;

    TRACE_VERBOSE(TRACE_IOCTL, "IOCTL received: 0x%08lX (InLen=%Iu, OutLen=%Iu)",
                  ioControlCode, inputBufferLength, outputBufferLength);

    switch (ioControlCode)
    {
    case IOCTL_RPUSB_PING:
        TRACE_INFO(TRACE_IOCTL, "IOCTL_RPUSB_PING");
        status = SendVendorControl(context, rpusb::kVendorRequestPing, 0, nullptr, 0);
        break;
    case IOCTL_RPUSB_GET_VERSION:
    {
        if (outputBufferLength < sizeof(RPUSB_DRIVER_VERSION))
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        WDFMEMORY outputMemory;
        status = WdfRequestRetrieveOutputMemory(request, &outputMemory);
        if (!NT_SUCCESS(status))
        {
            break;
        }

        RPUSB_DRIVER_VERSION version = {1, 0, 0};
        status = SendVendorControl(context,
                                   rpusb::kVendorRequestInit,
                                   0,
                                   &version,
                                   sizeof(version));
        if (NT_SUCCESS(status))
        {
            status = WdfMemoryCopyFromBuffer(outputMemory, 0, &version, sizeof(version));
        }
        break;
    }
    case IOCTL_RPUSB_PUSH_FRAME:
        if (inputBufferLength < sizeof(RPUSB_FRAME_HEADER))
        {
            TRACE_ERROR(TRACE_IOCTL, "IOCTL_RPUSB_PUSH_FRAME: Buffer too small (%Iu bytes, expected %Iu)",
                        inputBufferLength, sizeof(RPUSB_FRAME_HEADER));
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        else
        {
            WDFMEMORY inputMemory;
            status = WdfRequestRetrieveInputMemory(request, &inputMemory);
            if (!NT_SUCCESS(status))
            {
                TRACE_ERROR(TRACE_IOCTL, "WdfRequestRetrieveInputMemory failed: %!STATUS!", status);
                break;
            }

            auto* frameHeader = reinterpret_cast<RPUSB_FRAME_HEADER*>(WdfMemoryGetBuffer(inputMemory, nullptr));
            if (frameHeader->PayloadBytes == 0)
            {
                TRACE_ERROR(TRACE_IOCTL, "IOCTL_RPUSB_PUSH_FRAME: Invalid payload size (0 bytes)");
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            TRACE_VERBOSE(TRACE_IOCTL, "IOCTL_RPUSB_PUSH_FRAME: %lux%lu %lu bytes (Frame #%llu)",
                          frameHeader->Width, frameHeader->Height,
                          frameHeader->PayloadBytes,
                          context->Statistics.FramesSubmitted + 1);

            status = WdfUsbTargetPipeWriteSynchronously(context->BulkOut,
                                                         request,
                                                         nullptr,
                                                         inputMemory,
                                                         nullptr);
            if (NT_SUCCESS(status))
            {
                context->Statistics.FramesSubmitted++;
                context->Statistics.BytesTransferred += frameHeader->PayloadBytes;
                TRACE_VERBOSE(TRACE_IOCTL, "Frame transmitted successfully (Total frames: %llu, bytes: %llu)",
                              context->Statistics.FramesSubmitted,
                              context->Statistics.BytesTransferred);
            }
            else
            {
                TRACE_ERROR(TRACE_IOCTL, "WdfUsbTargetPipeWriteSynchronously failed: %!STATUS!", status);
            }
        }
        break;
    case IOCTL_RPUSB_SET_MODE:
    {
        if (inputBufferLength < sizeof(UINT32))
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        WDFMEMORY inputMemory;
        status = WdfRequestRetrieveInputMemory(request, &inputMemory);
        if (!NT_SUCCESS(status))
        {
            break;
        }

        auto* mode = reinterpret_cast<UINT32*>(WdfMemoryGetBuffer(inputMemory, nullptr));
        status = SendVendorControl(context,
                                   rpusb::kVendorRequestModeSet,
                                   static_cast<UINT16>(*mode),
                                   nullptr,
                                   0);
        break;
    }
    case IOCTL_RPUSB_GET_STATISTICS:
    {
        if (outputBufferLength < sizeof(RPUSB_STATISTICS))
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        WDFMEMORY outputMemory;
        status = WdfRequestRetrieveOutputMemory(request, &outputMemory);
        if (!NT_SUCCESS(status))
        {
            break;
        }

        status = WdfMemoryCopyFromBuffer(outputMemory, 0, &context->Statistics, sizeof(RPUSB_STATISTICS));
        break;
    }
    case IOCTL_RPUSB_GET_TOUCH_DATA:
    {
        if (outputBufferLength < sizeof(RPUSB_TOUCH_DATA))
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        WDFMEMORY outputMemory;
        status = WdfRequestRetrieveOutputMemory(request, &outputMemory);
        if (!NT_SUCCESS(status))
        {
            break;
        }

        // Read touch data from device context
        RPUSB_TOUCH_DATA touchData = {};
        WdfSpinLockAcquire(context->TouchData.Lock);
        touchData.ContactCount = context->TouchData.ContactCount;
        for (UINT32 i = 0; i < rpusb::MaxTouchContacts; ++i)
        {
            touchData.Contacts[i].ContactId = context->TouchData.Contacts[i].ContactId;
            touchData.Contacts[i].TipSwitch = context->TouchData.Contacts[i].TipSwitch;
            touchData.Contacts[i].InRange = context->TouchData.Contacts[i].InRange;
            touchData.Contacts[i].X = context->TouchData.Contacts[i].X;
            touchData.Contacts[i].Y = context->TouchData.Contacts[i].Y;
        }
        WdfSpinLockRelease(context->TouchData.Lock);

        TRACE_VERBOSE(TRACE_IOCTL, "IOCTL_RPUSB_GET_TOUCH_DATA: %u active contacts",
                      touchData.ContactCount);

        status = WdfMemoryCopyFromBuffer(outputMemory, 0, &touchData, sizeof(RPUSB_TOUCH_DATA));
        break;
    }
    default:
        TRACE_WARNING(TRACE_IOCTL, "Unknown IOCTL: 0x%08lX", ioControlCode);
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    if (!NT_SUCCESS(status))
    {
        TRACE_VERBOSE(TRACE_IOCTL, "IOCTL 0x%08lX completed with error: %!STATUS!",
                      ioControlCode, status);
    }

    WdfRequestComplete(request, status);
}
