#include "Device.h"

#include <initguid.h>
#include <usb.h>

#include "Queue.h"
#include "Trace.h"
#include "Device.tmh"  // Auto-generated by WPP preprocessor

namespace
{
    constexpr USHORT kVendorId = 0x1FC9;
    constexpr USHORT kProductId = 0x0094;
}

NTSTATUS UsbDeviceCreate(_Inout_ PWDFDEVICE_INIT deviceInit)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);

    WDF_PNPPOWER_EVENT_CALLBACKS pnpCallbacks;
    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpCallbacks);
    pnpCallbacks.EvtDevicePrepareHardware = UsbDevicePrepareHardware;
    pnpCallbacks.EvtDeviceReleaseHardware = UsbDeviceReleaseHardware;
    WdfDeviceInitSetPnpPowerEventCallbacks(deviceInit, &pnpCallbacks);

    WdfDeviceInitSetDeviceType(deviceInit, FILE_DEVICE_UNKNOWN);
    WdfDeviceInitSetExclusive(deviceInit, FALSE);

    WDF_FILEOBJECT_CONFIG fileConfig;
    WDF_FILEOBJECT_CONFIG_INIT(&fileConfig, WDF_NO_EVENT_CALLBACK, WDF_NO_EVENT_CALLBACK, WDF_NO_EVENT_CALLBACK);
    WdfDeviceInitSetFileObjectConfig(deviceInit, &fileConfig, WDF_NO_OBJECT_ATTRIBUTES);

    WDF_OBJECT_ATTRIBUTES deviceAttributes;
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DeviceContext);

    WDFDEVICE device;
    NTSTATUS status = WdfDeviceCreate(&deviceInit, &deviceAttributes, &device);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_DEVICE, "WdfDeviceCreate failed: %!STATUS!", status);
        return status;
    }

    status = WdfDeviceCreateDeviceInterface(device, &GUID_DEVINTERFACE_RPUSB_TRANSPORT, nullptr);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_DEVICE, "WdfDeviceCreateDeviceInterface failed: %!STATUS!", status);
        return status;
    }

    TRACE_INFO(TRACE_DEVICE, "Device interface created successfully");

    DeviceContext* context = GetDeviceContext(device);
    context->Statistics = {};

    // Initialize touch data buffer
    WDF_OBJECT_ATTRIBUTES lockAttributes;
    WDF_OBJECT_ATTRIBUTES_INIT(&lockAttributes);
    lockAttributes.ParentObject = device;
    status = WdfSpinLockCreate(&lockAttributes, &context->TouchData.Lock);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_DEVICE, "WdfSpinLockCreate failed: %!STATUS!", status);
        return status;
    }

    KeInitializeEvent(&context->TouchData.DataAvailable, SynchronizationEvent, FALSE);
    context->TouchData.ContactCount = 0;
    RtlZeroMemory(context->TouchData.Contacts, sizeof(context->TouchData.Contacts));

    TRACE_VERBOSE(TRACE_TOUCH, "Touch data buffer initialized");

    status = QueueCreate(device);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_DEVICE, "QueueCreate failed: %!STATUS!", status);
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DEVICE, status);
    return status;
}

NTSTATUS UsbDevicePrepareHardware(_In_ WDFDEVICE device,
                                  _In_ WDFCMRESLIST /*resourcesRaw*/,
                                  _In_ WDFCMRESLIST /*resourcesTranslated*/)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);

    auto* context = GetDeviceContext(device);

    WDF_USB_DEVICE_CREATE_CONFIG config;
    WDF_USB_DEVICE_CREATE_CONFIG_INIT(&config, USBD_CLIENT_CONTRACT_VERSION_602);

    NTSTATUS status = WdfUsbTargetDeviceCreateWithParameters(device, &config, WDF_NO_OBJECT_ATTRIBUTES, &context->UsbDevice);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_USB, "WdfUsbTargetDeviceCreateWithParameters failed: %!STATUS!", status);
        return status;
    }

    USB_DEVICE_DESCRIPTOR descriptor;
    status = WdfUsbTargetDeviceRetrieveDeviceDescriptor(context->UsbDevice, &descriptor);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_USB, "WdfUsbTargetDeviceRetrieveDeviceDescriptor failed: %!STATUS!", status);
        return status;
    }

    TRACE_INFO(TRACE_USB, "USB device descriptor: VID=0x%04X PID=0x%04X",
               descriptor.idVendor, descriptor.idProduct);

    if (descriptor.idVendor != kVendorId || descriptor.idProduct != kProductId)
    {
        TRACE_ERROR(TRACE_USB, "Invalid device VID/PID (expected VID=0x%04X PID=0x%04X)",
                    kVendorId, kProductId);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    status = WdfUsbTargetDeviceSelectConfig(context->UsbDevice, WDF_NO_OBJECT_ATTRIBUTES, nullptr);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_USB, "WdfUsbTargetDeviceSelectConfig failed: %!STATUS!", status);
        return status;
    }

    context->UsbInterface = WdfUsbTargetDeviceGetInterface(context->UsbDevice, 0);
    if (context->UsbInterface == nullptr)
    {
        TRACE_ERROR(TRACE_USB, "Failed to get USB interface 0");
        return STATUS_INVALID_DEVICE_STATE;
    }

    ULONG pipeCount = WdfUsbInterfaceGetNumConfiguredPipes(context->UsbInterface);
    TRACE_INFO(TRACE_USB, "Configuring %lu USB pipes", pipeCount);

    for (ULONG pipeIndex = 0; pipeIndex < pipeCount; ++pipeIndex)
    {
        WDFUSBPIPE pipe = WdfUsbInterfaceGetConfiguredPipe(context->UsbInterface, pipeIndex, nullptr);
        WDF_USB_PIPE_INFORMATION pipeInfo;
        WDF_USB_PIPE_INFORMATION_INIT(&pipeInfo);
        WdfUsbTargetPipeGetInformation(pipe, &pipeInfo);

        if (WdfUsbPipeTypeBulk == pipeInfo.PipeType && WdfUsbTargetPipeIsInEndpoint(pipe))
        {
            context->BulkIn = pipe;
            TRACE_INFO(TRACE_USB, "Bulk IN pipe found (EP 0x%02X, MaxPacket=%u)",
                       pipeInfo.EndpointAddress, pipeInfo.MaximumPacketSize);
        }
        else if (WdfUsbPipeTypeBulk == pipeInfo.PipeType && WdfUsbTargetPipeIsOutEndpoint(pipe))
        {
            context->BulkOut = pipe;
            TRACE_INFO(TRACE_USB, "Bulk OUT pipe found (EP 0x%02X, MaxPacket=%u)",
                       pipeInfo.EndpointAddress, pipeInfo.MaximumPacketSize);
        }
        else if (WdfUsbPipeTypeInterrupt == pipeInfo.PipeType && WdfUsbTargetPipeIsInEndpoint(pipe))
        {
            context->InterruptIn = pipe;
            TRACE_INFO(TRACE_USB, "Interrupt IN pipe found (EP 0x%02X, MaxPacket=%u)",
                       pipeInfo.EndpointAddress, pipeInfo.MaximumPacketSize);
        }
    }

    if (context->BulkIn == nullptr || context->BulkOut == nullptr)
    {
        TRACE_ERROR(TRACE_USB, "Required bulk pipes not found (BulkIn=%p, BulkOut=%p)",
                    context->BulkIn, context->BulkOut);
        return STATUS_INVALID_DEVICE_STATE;
    }

    if (context->InterruptIn != nullptr)
    {
        WDF_USB_CONTINUOUS_READER_CONFIG readerConfig;
        WDF_USB_CONTINUOUS_READER_CONFIG_INIT(&readerConfig, UsbInterruptCompletion, rpusb::DefaultInterruptPacketBytes);
        readerConfig.EvtUsbTargetPipeReadersFailed = nullptr;
        status = WdfUsbTargetPipeConfigContinuousReader(context->InterruptIn, &readerConfig);
        if (!NT_SUCCESS(status))
        {
            TRACE_ERROR(TRACE_USB, "WdfUsbTargetPipeConfigContinuousReader failed: %!STATUS!", status);
            return status;
        }

        TRACE_INFO(TRACE_USB, "Continuous reader configured for interrupt pipe");
    }
    else
    {
        TRACE_WARNING(TRACE_USB, "No interrupt IN pipe found - touch events will not be available");
    }

    context->DeviceReady = TRUE;
    TRACE_INFO(TRACE_DEVICE, "USB device prepared successfully and ready");
    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DEVICE, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

NTSTATUS UsbDeviceReleaseHardware(_In_ WDFDEVICE device,
                                  _In_ WDFCMRESLIST /*resourcesTranslated*/)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);

    auto* context = GetDeviceContext(device);
    context->DeviceReady = FALSE;

    TRACE_INFO(TRACE_DEVICE, "USB device hardware released");
    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DEVICE, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

VOID UsbInterruptCompletion(_In_ WDFUSBPIPE pipe,
                            _In_ WDFMEMORY buffer,
                            _In_ size_t numBytesTransferred,
                            _In_ WDFCONTEXT context)
{
    UNREFERENCED_PARAMETER(context);

    if (numBytesTransferred < sizeof(rpusb::InterruptPacket))
    {
        TRACE_WARNING(TRACE_USB, "Interrupt packet too small: %Iu bytes (expected %Iu)",
                      numBytesTransferred, sizeof(rpusb::InterruptPacket));
        return;
    }

    WDFDEVICE device = WdfIoTargetGetDevice(WdfUsbTargetPipeGetIoTarget(pipe));
    auto* deviceContext = GetDeviceContext(device);

    auto* packet = static_cast<rpusb::InterruptPacket*>(WdfMemoryGetBuffer(buffer, nullptr));
    if (packet == nullptr)
    {
        TRACE_ERROR(TRACE_USB, "Failed to get buffer from interrupt memory");
        return;
    }

    switch (packet->PacketType)
    {
        case rpusb::InterruptPacketType::Touch:
        {
            // Parse and store touch data
            WdfSpinLockAcquire(deviceContext->TouchData.Lock);

            // Simple strategy: store the touch contact based on ContactId
            UINT8 contactId = packet->Data.Touch.ContactId;
            if (contactId < rpusb::MaxTouchContacts)
            {
                deviceContext->TouchData.Contacts[contactId] = packet->Data.Touch;

                // Update contact count
                // Count how many contacts have TipSwitch set
                UINT8 activeCount = 0;
                for (UINT32 i = 0; i < rpusb::MaxTouchContacts; ++i)
                {
                    if (deviceContext->TouchData.Contacts[i].TipSwitch)
                    {
                        activeCount++;
                    }
                }
                deviceContext->TouchData.ContactCount = activeCount;

                TRACE_VERBOSE(TRACE_TOUCH, "Touch event: Contact=%u TipSwitch=%u InRange=%u X=%u Y=%u (Active contacts=%u)",
                              contactId,
                              packet->Data.Touch.TipSwitch,
                              packet->Data.Touch.InRange,
                              packet->Data.Touch.X,
                              packet->Data.Touch.Y,
                              activeCount);
            }
            else
            {
                TRACE_WARNING(TRACE_TOUCH, "Invalid contact ID: %u (max %u)",
                              contactId, rpusb::MaxTouchContacts - 1);
            }

            WdfSpinLockRelease(deviceContext->TouchData.Lock);

            // Signal that new touch data is available
            KeSetEvent(&deviceContext->TouchData.DataAvailable, IO_NO_INCREMENT, FALSE);
            break;
        }

        case rpusb::InterruptPacketType::Status:
        {
            // Handle status packet
            if (packet->Data.Status.ErrorCode != 0)
            {
                TRACE_ERROR(TRACE_USB, "Device reported error code: 0x%02X (LastFrameAcked=%lu)",
                            packet->Data.Status.ErrorCode,
                            packet->Data.Status.LastFrameAcked);
            }
            else
            {
                TRACE_VERBOSE(TRACE_USB, "Status packet: LastFrameAcked=%lu",
                              packet->Data.Status.LastFrameAcked);
            }
            break;
        }

        default:
            TRACE_WARNING(TRACE_USB, "Unknown interrupt packet type: 0x%02X",
                          static_cast<UINT8>(packet->PacketType));
            break;
    }
}
