#include "Pipeline.h"

#include <dxgi1_6.h>
#include <ntddk.h>

#include "../UsbTransportUmdf/UsbIoctl.h"
#include "../UsbTransportUmdf/UsbProtocol.h"

#include "Trace.h"
#include "Pipeline.tmh"  // Auto-generated by WPP preprocessor

namespace
{
    constexpr ULONG kFramePoolTag = 'frpR';
    constexpr ULONG kChunkPoolTag = 'kcpR';

    // Frame counter for unique frame IDs
    static volatile LONG g_frameCounter = 0;

    // Reconnect logic parameters
    constexpr UINT32 kMaxRetries = 3;
    constexpr UINT32 kInitialRetryDelayMs = 100;   // 100ms initial delay
    constexpr UINT32 kMaxRetryDelayMs = 2000;      // 2 second max delay

    PipelineContext g_context;

    struct PresentCompletion
    {
        explicit PresentCompletion(IDDCX_SWAPCHAIN chain) : SwapChain(chain) {}
        ~PresentCompletion()
        {
            if (SwapChain != nullptr)
            {
                IddCxSwapChainFinishedPresent(SwapChain);
            }
        }

        IDDCX_SWAPCHAIN SwapChain;
    };

    void CloseTransportTarget()
    {
        if (g_context.TransportTarget != nullptr)
        {
            TRACE_INFO(TRACE_PIPELINE, "Closing USB transport target");
            WdfIoTargetClose(g_context.TransportTarget);
            WdfObjectDelete(g_context.TransportTarget);
            g_context.TransportTarget = nullptr;
        }
    }

    // Send IOCTL with retry and exponential backoff
    NTSTATUS SendIoctlWithRetry(_In_ ULONG ioControlCode,
                                 _In_ PVOID inputBuffer,
                                 _In_ ULONG inputBufferSize,
                                 _In_ UINT32 chunkIndex,
                                 _In_ UINT32 totalChunks)
    {
        NTSTATUS status = STATUS_UNSUCCESSFUL;
        UINT32 retryDelay = kInitialRetryDelayMs;

        for (UINT32 retry = 0; retry <= kMaxRetries; ++retry)
        {
            // Ensure transport target is available (reconnect if needed)
            status = EnsureTransportTarget();
            if (!NT_SUCCESS(status))
            {
                if (retry < kMaxRetries)
                {
                    TRACE_WARNING(TRACE_PIPELINE, "Transport target unavailable (attempt %lu/%lu), retrying in %lu ms",
                                  retry + 1, kMaxRetries + 1, retryDelay);

                    // Use passive-level delay (KeDelayExecutionThread requires IRQL <= APC_LEVEL)
                    LARGE_INTEGER interval;
                    interval.QuadPart = -10000LL * retryDelay;  // Convert ms to 100ns units (negative = relative)
                    KeDelayExecutionThread(KernelMode, FALSE, &interval);

                    // Exponential backoff
                    retryDelay = min(retryDelay * 2, kMaxRetryDelayMs);
                    continue;
                }
                TRACE_ERROR(TRACE_PIPELINE, "Transport target unavailable after %lu retries", kMaxRetries + 1);
                return status;
            }

            // Send IOCTL
            WDF_MEMORY_DESCRIPTOR inputDesc;
            WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(&inputDesc, inputBuffer, inputBufferSize);

            status = WdfIoTargetSendIoctlSynchronously(g_context.TransportTarget,
                                                       nullptr,
                                                       ioControlCode,
                                                       &inputDesc,
                                                       nullptr,
                                                       nullptr);

            if (NT_SUCCESS(status))
            {
                // Success
                if (retry > 0)
                {
                    TRACE_INFO(TRACE_PIPELINE, "IOCTL succeeded after %lu retries", retry);
                }
                return status;
            }

            // Failed - close target and retry
            TRACE_WARNING(TRACE_PIPELINE, "IOCTL failed: %!STATUS! (attempt %lu/%lu, chunk %lu/%lu)",
                          status, retry + 1, kMaxRetries + 1, chunkIndex + 1, totalChunks);

            CloseTransportTarget();

            if (retry < kMaxRetries)
            {
                TRACE_INFO(TRACE_PIPELINE, "Retrying in %lu ms...", retryDelay);

                LARGE_INTEGER interval;
                interval.QuadPart = -10000LL * retryDelay;
                KeDelayExecutionThread(KernelMode, FALSE, &interval);

                // Exponential backoff
                retryDelay = min(retryDelay * 2, kMaxRetryDelayMs);
            }
        }

        TRACE_ERROR(TRACE_PIPELINE, "IOCTL failed after %lu retries: %!STATUS!", kMaxRetries + 1, status);
        return status;
    }

    NTSTATUS EnsureTransportTarget()
    {
        if (g_context.TransportTarget != nullptr)
        {
            return STATUS_SUCCESS;
        }

        if (g_context.ParentDevice == nullptr)
        {
            TRACE_ERROR(TRACE_PIPELINE, "Parent device is null");
            return STATUS_INVALID_DEVICE_STATE;
        }

        TRACE_VERBOSE(TRACE_PIPELINE, "Searching for USB transport device interface");

        PWSTR symbolicLinkList = nullptr;
        NTSTATUS status = IoGetDeviceInterfaces(&GUID_DEVINTERFACE_RPUSB_TRANSPORT,
                                                nullptr,
                                                DEVICE_INTERFACE_ACTIVE,
                                                &symbolicLinkList);
        if (!NT_SUCCESS(status))
        {
            TRACE_ERROR(TRACE_PIPELINE, "IoGetDeviceInterfaces failed: %!STATUS!", status);
            return status;
        }

        if (symbolicLinkList[0] == UNICODE_NULL)
        {
            TRACE_WARNING(TRACE_PIPELINE, "USB transport device interface not found (device may not be enumerated yet)");
            ExFreePool(symbolicLinkList);
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        UNICODE_STRING targetName;
        RtlInitUnicodeString(&targetName, symbolicLinkList);

        TRACE_INFO(TRACE_PIPELINE, "Opening USB transport target");

        status = WdfIoTargetCreate(g_context.ParentDevice, WDF_NO_OBJECT_ATTRIBUTES, &g_context.TransportTarget);
        if (NT_SUCCESS(status))
        {
            WDF_IO_TARGET_OPEN_PARAMS openParams;
            WDF_IO_TARGET_OPEN_PARAMS_INIT_OPEN_BY_NAME(&openParams, &targetName, GENERIC_READ | GENERIC_WRITE);
            openParams.ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
            openParams.CreateDisposition = FILE_OPEN;

            status = WdfIoTargetOpen(g_context.TransportTarget, &openParams);
            if (!NT_SUCCESS(status))
            {
                TRACE_ERROR(TRACE_PIPELINE, "WdfIoTargetOpen failed: %!STATUS!", status);
                WdfObjectDelete(g_context.TransportTarget);
                g_context.TransportTarget = nullptr;
            }
            else
            {
                TRACE_INFO(TRACE_PIPELINE, "USB transport target opened successfully");
            }
        }
        else
        {
            TRACE_ERROR(TRACE_PIPELINE, "WdfIoTargetCreate failed: %!STATUS!", status);
        }

        ExFreePool(symbolicLinkList);
        return status;
    }

    void ConvertBgraToRgb565(const BYTE* srcRow, UINT32 width, UINT16* dstRow)
    {
        for (UINT32 x = 0; x < width; ++x)
        {
            const BYTE* pixel = srcRow + (x * 4);
            BYTE b = pixel[0];
            BYTE g = pixel[1];
            BYTE r = pixel[2];
            dstRow[x] = static_cast<UINT16>(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
        }
    }
}

NTSTATUS PipelineInitialize(_In_ WDFDEVICE device)
{
    TRACE_FUNCTION_ENTRY(TRACE_PIPELINE);

    g_context.ParentDevice = device;

    TRACE_INFO(TRACE_PIPELINE, "Initializing pipeline and connecting to USB transport");

    NTSTATUS status = EnsureTransportTarget();
    if (!NT_SUCCESS(status))
    {
        // The display stack may load before the USB transport enumerates.  Defer
        // binding until the first present if we cannot locate the interface
        // yet to keep the adapter online for hot-plug scenarios.
        TRACE_WARNING(TRACE_PIPELINE, "USB transport not available yet (will retry on first present): %!STATUS!", status);
        status = STATUS_SUCCESS;
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_PIPELINE, status);
    return status;
}

void PipelineHandlePresent(_In_ IDDCX_SWAPCHAIN swapChain, _In_ const IDARG_IN_PRESENT* presentArgs)
{
    UNREFERENCED_PARAMETER(presentArgs);

    PresentCompletion completion(swapChain);

    if (!NT_SUCCESS(EnsureTransportTarget()))
    {
        TRACE_ERROR(TRACE_PIPELINE, "USB transport target not available (frame dropped)");
        return;
    }

    // Acquire buffer from IddCx swap chain using proper IddCx API
    IDARG_IN_SWAPCHAINGETBUFFER getBuffer = {};
    getBuffer.pSwapChain = swapChain;

    Microsoft::WRL::ComPtr<IDXGISurface> surface;
    NTSTATUS status = IddCxSwapChainGetBuffer(&getBuffer, IID_PPV_ARGS(&surface));
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_PIPELINE, "IddCxSwapChainGetBuffer failed: %!STATUS!", status);
        return;
    }

    // Get surface description
    DXGI_SURFACE_DESC desc = {};
    if (FAILED(surface->GetDesc(&desc)))
    {
        TRACE_ERROR(TRACE_PIPELINE, "Failed to get surface description");
        return;
    }

    const UINT32 width = desc.Width;
    const UINT32 height = desc.Height;
    if (width == 0 || height == 0 || desc.Format != DXGI_FORMAT_B8G8R8A8_UNORM)
    {
        TRACE_ERROR(TRACE_PIPELINE, "Invalid surface format: %lux%lu format=%u (expected BGRA8888)",
                    width, height, desc.Format);
        return;
    }

    TRACE_VERBOSE(TRACE_PIPELINE, "Processing frame: %lux%lu BGRA -> RGB565", width, height);

    // Map the surface for reading
    DXGI_MAPPED_RECT mapped = {};
    if (FAILED(surface->Map(&mapped, DXGI_MAP_READ)))
    {
        TRACE_ERROR(TRACE_PIPELINE, "Failed to map surface for reading");
        return;
    }

    // Allocate buffer for RGB565 frame
    const UINT32 payloadBytes = width * height * sizeof(UINT16);
    const size_t totalBytes = sizeof(RPUSB_FRAME_HEADER) + payloadBytes;
    auto* frameBuffer = static_cast<BYTE*>(ExAllocatePoolWithTag(NonPagedPoolNx, totalBytes, kFramePoolTag));
    if (frameBuffer == nullptr)
    {
        TRACE_ERROR(TRACE_PIPELINE, "Failed to allocate frame buffer (%Iu bytes)", totalBytes);
        surface->Unmap();
        return;
    }

    // Fill frame header
    auto* frameHeader = reinterpret_cast<RPUSB_FRAME_HEADER*>(frameBuffer);
    frameHeader->Width = width;
    frameHeader->Height = height;
    frameHeader->PixelFormat = static_cast<UINT32>(rpusb::PixelFormat::Rgb565);
    frameHeader->PayloadBytes = payloadBytes;

    TRACE_VERBOSE(TRACE_PIPELINE, "Converting BGRA to RGB565 (%lu bytes payload)", payloadBytes);

    // Convert BGRA to RGB565
    auto* pixelData = reinterpret_cast<UINT16*>(frameHeader + 1);
    for (UINT32 row = 0; row < height; ++row)
    {
        const BYTE* srcRow = mapped.pBits + (row * mapped.Pitch);
        UINT16* dstRow = pixelData + (row * width);
        ConvertBgraToRgb565(srcRow, width, dstRow);
    }

    surface->Unmap();

    // Generate unique frame ID
    UINT32 frameId = InterlockedIncrement(&g_frameCounter);

    // Calculate chunking parameters
    const UINT32 chunkDataSize = rpusb::ChunkSize - sizeof(RPUSB_CHUNK_HEADER);
    const UINT32 totalChunks = (payloadBytes + chunkDataSize - 1) / chunkDataSize;

    TRACE_VERBOSE(TRACE_PIPELINE, "Sending frame #%lu to USB transport in %lu chunks (%lu bytes total)",
                  frameId, totalChunks, payloadBytes);

    // Send frame in chunks
    BOOLEAN allChunksSent = TRUE;
    for (UINT32 chunkIndex = 0; chunkIndex < totalChunks; ++chunkIndex)
    {
        const UINT32 offset = chunkIndex * chunkDataSize;
        const UINT32 remainingBytes = payloadBytes - offset;
        const UINT32 currentChunkDataSize = remainingBytes < chunkDataSize ? remainingBytes : chunkDataSize;
        const UINT32 chunkTotalSize = sizeof(RPUSB_CHUNK_HEADER) + currentChunkDataSize;

        // Allocate chunk buffer
        auto* chunkBuffer = static_cast<BYTE*>(ExAllocatePoolWithTag(NonPagedPoolNx, chunkTotalSize, kChunkPoolTag));
        if (chunkBuffer == nullptr)
        {
            TRACE_ERROR(TRACE_PIPELINE, "Failed to allocate chunk buffer (%lu bytes) for chunk %lu/%lu",
                        chunkTotalSize, chunkIndex + 1, totalChunks);
            allChunksSent = FALSE;
            break;
        }

        // Fill chunk header
        auto* chunkHeader = reinterpret_cast<RPUSB_CHUNK_HEADER*>(chunkBuffer);
        chunkHeader->FrameId = frameId;
        chunkHeader->ChunkIndex = chunkIndex;
        chunkHeader->TotalChunks = totalChunks;
        chunkHeader->ChunkBytes = currentChunkDataSize;
        chunkHeader->Width = width;
        chunkHeader->Height = height;
        chunkHeader->PixelFormat = static_cast<UINT32>(rpusb::PixelFormat::Rgb565);
        chunkHeader->TotalBytes = payloadBytes;

        // Copy chunk data
        RtlCopyMemory(chunkBuffer + sizeof(RPUSB_CHUNK_HEADER),
                      pixelData + (offset / sizeof(UINT16)),
                      currentChunkDataSize);

        // Send chunk with retry logic
        status = SendIoctlWithRetry(IOCTL_RPUSB_PUSH_FRAME_CHUNK,
                                     chunkBuffer,
                                     chunkTotalSize,
                                     chunkIndex,
                                     totalChunks);

        ExFreePool(chunkBuffer);

        if (!NT_SUCCESS(status))
        {
            TRACE_ERROR(TRACE_PIPELINE, "Failed to send chunk %lu/%lu after retries: %!STATUS!",
                        chunkIndex + 1, totalChunks, status);
            allChunksSent = FALSE;
            break;
        }

        TRACE_VERBOSE(TRACE_PIPELINE, "Chunk %lu/%lu sent (%lu bytes)", chunkIndex + 1, totalChunks, currentChunkDataSize);
    }

    if (allChunksSent)
    {
        TRACE_VERBOSE(TRACE_PIPELINE, "Frame #%lu sent successfully (%lu chunks, %lu bytes total)",
                      frameId, totalChunks, payloadBytes);
    }
    else
    {
        TRACE_ERROR(TRACE_PIPELINE, "Frame #%lu transmission incomplete", frameId);
    }

    ExFreePool(frameBuffer);
}

void PipelineTeardown()
{
    TRACE_FUNCTION_ENTRY(TRACE_PIPELINE);
    TRACE_INFO(TRACE_PIPELINE, "Tearing down pipeline");

    CloseTransportTarget();
    g_context.ParentDevice = nullptr;

    TRACE_FUNCTION_EXIT(TRACE_PIPELINE);
}
