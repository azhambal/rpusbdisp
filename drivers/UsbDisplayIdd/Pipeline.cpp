#include "Pipeline.h"

#include <dxgi1_6.h>
#include <ntddk.h>

#include "../UsbTransportUmdf/UsbIoctl.h"
#include "../UsbTransportUmdf/UsbProtocol.h"

#include "Trace.h"
#include "Pipeline.tmh"  // Auto-generated by WPP preprocessor

namespace
{
    constexpr ULONG kFramePoolTag = 'frpR';

    PipelineContext g_context;

    struct PresentCompletion
    {
        explicit PresentCompletion(IDDCX_SWAPCHAIN chain) : SwapChain(chain) {}
        ~PresentCompletion()
        {
            if (SwapChain != nullptr)
            {
                IddCxSwapChainFinishedPresent(SwapChain);
            }
        }

        IDDCX_SWAPCHAIN SwapChain;
    };

    void CloseTransportTarget()
    {
        if (g_context.TransportTarget != nullptr)
        {
            TRACE_INFO(TRACE_PIPELINE, "Closing USB transport target");
            WdfIoTargetClose(g_context.TransportTarget);
            WdfObjectDelete(g_context.TransportTarget);
            g_context.TransportTarget = nullptr;
        }
    }

    NTSTATUS EnsureTransportTarget()
    {
        if (g_context.TransportTarget != nullptr)
        {
            return STATUS_SUCCESS;
        }

        if (g_context.ParentDevice == nullptr)
        {
            TRACE_ERROR(TRACE_PIPELINE, "Parent device is null");
            return STATUS_INVALID_DEVICE_STATE;
        }

        TRACE_VERBOSE(TRACE_PIPELINE, "Searching for USB transport device interface");

        PWSTR symbolicLinkList = nullptr;
        NTSTATUS status = IoGetDeviceInterfaces(&GUID_DEVINTERFACE_RPUSB_TRANSPORT,
                                                nullptr,
                                                DEVICE_INTERFACE_ACTIVE,
                                                &symbolicLinkList);
        if (!NT_SUCCESS(status))
        {
            TRACE_ERROR(TRACE_PIPELINE, "IoGetDeviceInterfaces failed: %!STATUS!", status);
            return status;
        }

        if (symbolicLinkList[0] == UNICODE_NULL)
        {
            TRACE_WARNING(TRACE_PIPELINE, "USB transport device interface not found (device may not be enumerated yet)");
            ExFreePool(symbolicLinkList);
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        UNICODE_STRING targetName;
        RtlInitUnicodeString(&targetName, symbolicLinkList);

        TRACE_INFO(TRACE_PIPELINE, "Opening USB transport target");

        status = WdfIoTargetCreate(g_context.ParentDevice, WDF_NO_OBJECT_ATTRIBUTES, &g_context.TransportTarget);
        if (NT_SUCCESS(status))
        {
            WDF_IO_TARGET_OPEN_PARAMS openParams;
            WDF_IO_TARGET_OPEN_PARAMS_INIT_OPEN_BY_NAME(&openParams, &targetName, GENERIC_READ | GENERIC_WRITE);
            openParams.ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
            openParams.CreateDisposition = FILE_OPEN;

            status = WdfIoTargetOpen(g_context.TransportTarget, &openParams);
            if (!NT_SUCCESS(status))
            {
                TRACE_ERROR(TRACE_PIPELINE, "WdfIoTargetOpen failed: %!STATUS!", status);
                WdfObjectDelete(g_context.TransportTarget);
                g_context.TransportTarget = nullptr;
            }
            else
            {
                TRACE_INFO(TRACE_PIPELINE, "USB transport target opened successfully");
            }
        }
        else
        {
            TRACE_ERROR(TRACE_PIPELINE, "WdfIoTargetCreate failed: %!STATUS!", status);
        }

        ExFreePool(symbolicLinkList);
        return status;
    }

    void ConvertBgraToRgb565(const BYTE* srcRow, UINT32 width, UINT16* dstRow)
    {
        for (UINT32 x = 0; x < width; ++x)
        {
            const BYTE* pixel = srcRow + (x * 4);
            BYTE b = pixel[0];
            BYTE g = pixel[1];
            BYTE r = pixel[2];
            dstRow[x] = static_cast<UINT16>(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
        }
    }
}

NTSTATUS PipelineInitialize(_In_ WDFDEVICE device)
{
    TRACE_FUNCTION_ENTRY(TRACE_PIPELINE);

    g_context.ParentDevice = device;

    TRACE_INFO(TRACE_PIPELINE, "Initializing pipeline and connecting to USB transport");

    NTSTATUS status = EnsureTransportTarget();
    if (!NT_SUCCESS(status))
    {
        // The display stack may load before the USB transport enumerates.  Defer
        // binding until the first present if we cannot locate the interface
        // yet to keep the adapter online for hot-plug scenarios.
        TRACE_WARNING(TRACE_PIPELINE, "USB transport not available yet (will retry on first present): %!STATUS!", status);
        status = STATUS_SUCCESS;
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_PIPELINE, status);
    return status;
}

void PipelineHandlePresent(_In_ IDDCX_SWAPCHAIN swapChain, _In_ const IDARG_IN_PRESENT* presentArgs)
{
    UNREFERENCED_PARAMETER(presentArgs);

    PresentCompletion completion(swapChain);

    if (!NT_SUCCESS(EnsureTransportTarget()))
    {
        TRACE_ERROR(TRACE_PIPELINE, "USB transport target not available (frame dropped)");
        return;
    }

    // Acquire buffer from IddCx swap chain using proper IddCx API
    IDARG_IN_SWAPCHAINGETBUFFER getBuffer = {};
    getBuffer.pSwapChain = swapChain;

    Microsoft::WRL::ComPtr<IDXGISurface> surface;
    NTSTATUS status = IddCxSwapChainGetBuffer(&getBuffer, IID_PPV_ARGS(&surface));
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_PIPELINE, "IddCxSwapChainGetBuffer failed: %!STATUS!", status);
        return;
    }

    // Get surface description
    DXGI_SURFACE_DESC desc = {};
    if (FAILED(surface->GetDesc(&desc)))
    {
        TRACE_ERROR(TRACE_PIPELINE, "Failed to get surface description");
        return;
    }

    const UINT32 width = desc.Width;
    const UINT32 height = desc.Height;
    if (width == 0 || height == 0 || desc.Format != DXGI_FORMAT_B8G8R8A8_UNORM)
    {
        TRACE_ERROR(TRACE_PIPELINE, "Invalid surface format: %lux%lu format=%u (expected BGRA8888)",
                    width, height, desc.Format);
        return;
    }

    TRACE_VERBOSE(TRACE_PIPELINE, "Processing frame: %lux%lu BGRA -> RGB565", width, height);

    // Map the surface for reading
    DXGI_MAPPED_RECT mapped = {};
    if (FAILED(surface->Map(&mapped, DXGI_MAP_READ)))
    {
        TRACE_ERROR(TRACE_PIPELINE, "Failed to map surface for reading");
        return;
    }

    // Allocate buffer for RGB565 frame
    const UINT32 payloadBytes = width * height * sizeof(UINT16);
    const size_t totalBytes = sizeof(RPUSB_FRAME_HEADER) + payloadBytes;
    auto* frameBuffer = static_cast<BYTE*>(ExAllocatePoolWithTag(NonPagedPoolNx, totalBytes, kFramePoolTag));
    if (frameBuffer == nullptr)
    {
        TRACE_ERROR(TRACE_PIPELINE, "Failed to allocate frame buffer (%Iu bytes)", totalBytes);
        surface->Unmap();
        return;
    }

    // Fill frame header
    auto* frameHeader = reinterpret_cast<RPUSB_FRAME_HEADER*>(frameBuffer);
    frameHeader->Width = width;
    frameHeader->Height = height;
    frameHeader->PixelFormat = static_cast<UINT32>(rpusb::PixelFormat::Rgb565);
    frameHeader->PayloadBytes = payloadBytes;

    TRACE_VERBOSE(TRACE_PIPELINE, "Converting BGRA to RGB565 (%lu bytes payload)", payloadBytes);

    // Convert BGRA to RGB565
    auto* pixelData = reinterpret_cast<UINT16*>(frameHeader + 1);
    for (UINT32 row = 0; row < height; ++row)
    {
        const BYTE* srcRow = mapped.pBits + (row * mapped.Pitch);
        UINT16* dstRow = pixelData + (row * width);
        ConvertBgraToRgb565(srcRow, width, dstRow);
    }

    surface->Unmap();

    TRACE_VERBOSE(TRACE_PIPELINE, "Sending frame to USB transport (%Iu bytes total)", totalBytes);

    // Send frame to USB transport
    WDF_MEMORY_DESCRIPTOR inputDesc;
    WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(&inputDesc, frameBuffer, static_cast<ULONG>(totalBytes));

    status = WdfIoTargetSendIoctlSynchronously(g_context.TransportTarget,
                                               nullptr,
                                               IOCTL_RPUSB_PUSH_FRAME,
                                               &inputDesc,
                                               nullptr,
                                               nullptr);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_PIPELINE, "Failed to send frame to USB transport: %!STATUS! (closing transport target)", status);
        CloseTransportTarget();
    }
    else
    {
        TRACE_VERBOSE(TRACE_PIPELINE, "Frame sent successfully to USB transport");
    }

    ExFreePool(frameBuffer);
}

void PipelineTeardown()
{
    TRACE_FUNCTION_ENTRY(TRACE_PIPELINE);
    TRACE_INFO(TRACE_PIPELINE, "Tearing down pipeline");

    CloseTransportTarget();
    g_context.ParentDevice = nullptr;

    TRACE_FUNCTION_EXIT(TRACE_PIPELINE);
}
