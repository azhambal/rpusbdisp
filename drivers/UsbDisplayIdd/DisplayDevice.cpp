#include "DisplayDevice.h"
#include "Pipeline.h"

#include <ntddk.h>

#include "Trace.h"
#include "DisplayDevice.tmh"  // Auto-generated by WPP preprocessor

namespace
{
    IDARG_IN_ADAPTER_CREATE CreateAdapterArgs(WDFDEVICE device, DisplayDeviceContext* context)
    {
        IDARG_IN_ADAPTER_CREATE args = {};
        args.pWdfDevice = device;
        args.DriverConfig.ClientId = L"RoboPeakUsbDisplay";
        args.DriverConfig.EvtIddCxAdapterInitFinished = DisplayEvtAdapterInitFinished;
        args.DriverConfig.EvtIddCxAdapterCommitModes = DisplayEvtAdapterCommitModes;
        args.DriverConfig.EvtIddCxAdapterMonitorAssignSwapChain = DisplayEvtAssignSwapChain;
        args.DriverConfig.EvtIddCxAdapterMonitorUnassignSwapChain = DisplayEvtUnassignSwapChain;
        args.DriverConfig.Flags.Value = 0;
        args.pAdapterContext = context;
        return args;
    }

    VOID PresentProcessingThread(_In_ PVOID context)
    {
        auto* swapChainCtx = static_cast<SwapChainContext*>(context);

        TRACE_INFO(TRACE_PRESENT, "Present processing thread started");

        ULONG frameCount = 0;

        while (!swapChainCtx->ShouldStop)
        {
            // Wait for a short interval or until stop event is signaled
            LARGE_INTEGER timeout;
            timeout.QuadPart = -100000LL; // 10ms in 100-nanosecond units (negative for relative)

            NTSTATUS waitStatus = KeWaitForSingleObject(&swapChainCtx->StopEvent,
                                                        Executive,
                                                        KernelMode,
                                                        FALSE,
                                                        &timeout);
            if (waitStatus != STATUS_TIMEOUT)
            {
                TRACE_INFO(TRACE_PRESENT, "Present processing thread stopping (stop event signaled)");
                break;
            }

            // Try to acquire and release a buffer from the swap chain
            IDARG_OUT_RELEASEANDACQUIREBUFFER buffer = {};
            NTSTATUS status = IddCxSwapChainReleaseAndAcquireBuffer(swapChainCtx->SwapChain, &buffer);

            if (NT_SUCCESS(status))
            {
                // Process the present - PipelineHandlePresent will call IddCxSwapChainFinishedPresent
                if (buffer.pSurfaceAvailable != nullptr)
                {
                    frameCount++;
                    TRACE_VERBOSE(TRACE_PRESENT, "Processing frame #%lu", frameCount);

                    IDARG_IN_PRESENT presentArgs = {};
                    presentArgs.SurfaceAvailable = *buffer.pSurfaceAvailable;
                    PipelineHandlePresent(swapChainCtx->SwapChain, &presentArgs);
                }
            }
            else if (status == STATUS_TIMEOUT || status == STATUS_NO_MORE_ENTRIES)
            {
                // No buffer available, continue loop
                continue;
            }
            else
            {
                TRACE_ERROR(TRACE_PRESENT, "IddCxSwapChainReleaseAndAcquireBuffer failed: %!STATUS! (stopping thread)", status);
                break;
            }
        }

        TRACE_INFO(TRACE_PRESENT, "Present processing thread terminated (processed %lu frames)", frameCount);
        PsTerminateSystemThread(STATUS_SUCCESS);
    }
}

_Use_decl_annotations_
NTSTATUS DisplayEvtPrepareHardware(WDFDEVICE device,
                                   WDFCMRESLIST /*resourcesRaw*/,
                                   WDFCMRESLIST /*resourcesTranslated*/)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);

    auto* context = GetDisplayContext(device);

    TRACE_INFO(TRACE_DISPLAY, "Initializing IddCx adapter");

    IDARG_IN_ADAPTER_CREATE create = CreateAdapterArgs(device, context);
    IDARG_OUT_ADAPTER_CREATE createOut = {};
    NTSTATUS status = IddCxAdapterInitAsync(&create, sizeof(create), &createOut);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_DISPLAY, "IddCxAdapterInitAsync failed: %!STATUS!", status);
        return status;
    }

    context->Adapter = createOut.AdapterObject;
    TRACE_INFO(TRACE_DISPLAY, "IddCx adapter created successfully");

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DEVICE, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

_Use_decl_annotations_
NTSTATUS DisplayEvtReleaseHardware(WDFDEVICE device,
                                   WDFCMRESLIST /*resourcesTranslated*/)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);

    auto* context = GetDisplayContext(device);

    if (context->Monitor != nullptr)
    {
        TRACE_INFO(TRACE_DISPLAY, "Unregistering monitor");
        IddCxMonitorUnregister(context->Monitor);
        context->Monitor = nullptr;
    }

    if (context->Adapter != nullptr)
    {
        TRACE_INFO(TRACE_DISPLAY, "Closing IddCx adapter");
        IddCxAdapterClose(context->Adapter);
        context->Adapter = nullptr;
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DEVICE, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

_Use_decl_annotations_
VOID DisplayEvtSurpriseRemoval(WDFDEVICE device)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);
    TRACE_WARNING(TRACE_DEVICE, "Display device surprise removal detected");

    auto* context = GetDisplayContext(device);

    // Stop present thread if active
    if (context->SwapChainCtx.PresentThread != nullptr)
    {
        TRACE_INFO(TRACE_DISPLAY, "Stopping present thread due to device removal");
        context->SwapChainCtx.ShouldStop = TRUE;
        KeSetEvent(&context->SwapChainCtx.StopEvent, IO_NO_INCREMENT, FALSE);

        // Wait for thread to terminate (with timeout)
        LARGE_INTEGER timeout;
        timeout.QuadPart = -10000000LL;  // 1 second timeout (negative = relative)

        NTSTATUS waitStatus = KeWaitForSingleObject(context->SwapChainCtx.PresentThread,
                                                     Executive,
                                                     KernelMode,
                                                     FALSE,
                                                     &timeout);

        if (waitStatus == STATUS_TIMEOUT)
        {
            TRACE_WARNING(TRACE_DISPLAY, "Present thread did not stop within timeout");
        }
        else
        {
            TRACE_INFO(TRACE_DISPLAY, "Present thread stopped successfully");
        }

        context->SwapChainCtx.PresentThread = nullptr;
    }

    // Close USB transport target to prevent further frame transmission attempts
    PipelineTeardown();

    TRACE_INFO(TRACE_DEVICE, "Surprise removal cleanup complete");
    TRACE_FUNCTION_EXIT(TRACE_DEVICE);
}

_Use_decl_annotations_
NTSTATUS DisplayEvtAdapterInitFinished(IDDCX_ADAPTER adapter, const IDARG_IN_ADAPTER_INIT_FINISHED* args)
{
    TRACE_FUNCTION_ENTRY(TRACE_DISPLAY);

    auto* context = reinterpret_cast<DisplayDeviceContext*>(args->pContext);

    TRACE_INFO(TRACE_DISPLAY, "IddCx adapter initialization finished");

    IDARG_OUT_MONITOR_CREATE monitorCreate = {};
    IDARG_IN_MONITORCREATE monitorCreateArgs = {};
    monitorCreateArgs.AdapterObject = adapter;
    monitorCreateArgs.MonitorInfo.Size = sizeof(IDDCX_MONITOR_INFO);
    monitorCreateArgs.MonitorInfo.MonitorType = DISPLAYCONFIG_OUTPUT_TECHNOLOGY_USB;
    monitorCreateArgs.MonitorInfo.ConnectorType = DISPLAYCONFIG_CONNECTOR_TYPE_USB;
    monitorCreateArgs.MonitorInfo.MonitorDescription.pEdid = rpusb::idd::kEdid320x240;
    monitorCreateArgs.MonitorInfo.MonitorDescription.EdidLength = sizeof(rpusb::idd::kEdid320x240);

    TRACE_INFO(TRACE_DISPLAY, "Creating monitor (USB, 320x240)");

    NTSTATUS status = IddCxMonitorCreate(&monitorCreateArgs, &monitorCreate);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_DISPLAY, "IddCxMonitorCreate failed: %!STATUS!", status);
        return status;
    }

    // Native display mode: 320x240 @ 60Hz (RGB565 - 65536 colors)
    IDDCX_MONITOR_MODE mode = {};
    mode.Size = sizeof(IDDCX_MONITOR_MODE);
    mode.VideoSignalInfo.activeSize.cx = 320;
    mode.VideoSignalInfo.activeSize.cy = 240;
    mode.VideoSignalInfo.vSyncFreq.Numerator = 60;
    mode.VideoSignalInfo.vSyncFreq.Denominator = 1;
    mode.BitsPerPixel = 16;  // RGB565 = 16 bits per pixel (65536 colors)
    mode.ColorBasis = IDDCX_COLOR_BASIS_SRGB;
    mode.PixelFormat = DXGI_FORMAT_B8G8R8A8_UNORM;  // Windows uses BGRA8888, convert to RGB565

    TRACE_INFO(TRACE_DISPLAY, "Monitor mode: %lux%lu@%luHz %u bpp (RGB565)",
               mode.VideoSignalInfo.activeSize.cx,
               mode.VideoSignalInfo.activeSize.cy,
               mode.VideoSignalInfo.vSyncFreq.Numerator / mode.VideoSignalInfo.vSyncFreq.Denominator,
               mode.BitsPerPixel);

    IDARG_IN_MONITORARRIVAL arrival = {};
    arrival.AdapterObject = adapter;
    arrival.MonitorObject = monitorCreate.MonitorObject;
    arrival.MonitorModes = &mode;
    arrival.MonitorModeCount = 1;
    arrival.DefaultMonitorModeIndex = 0;

    status = IddCxMonitorArrival(&arrival);
    if (NT_SUCCESS(status))
    {
        context->Monitor = monitorCreate.MonitorObject;
        TRACE_INFO(TRACE_DISPLAY, "Monitor registered successfully");
    }
    else
    {
        TRACE_ERROR(TRACE_DISPLAY, "IddCxMonitorArrival failed: %!STATUS!", status);
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DISPLAY, status);
    return status;
}

_Use_decl_annotations_
NTSTATUS DisplayEvtAdapterCommitModes(IDDCX_ADAPTER adapter, const IDARG_IN_COMMIT_MODES* args)
{
    TRACE_FUNCTION_ENTRY(TRACE_DISPLAY);

    if (args->PathCount > 0)
    {
        TRACE_INFO(TRACE_DISPLAY, "Committing %lu display path(s)", args->PathCount);

        // Get the adapter context to access the device context
        auto* context = reinterpret_cast<DisplayDeviceContext*>(args->pContext);
        if (context != nullptr)
        {
            // Update current mode from the first path
            const IDDCX_PATH& path = args->pPaths[0];
            context->CurrentWidth = path.TargetModeInfo.activeSize.cx;
            context->CurrentHeight = path.TargetModeInfo.activeSize.cy;

            TRACE_INFO(TRACE_DISPLAY, "Active mode changed to: %lux%lu@%luHz",
                       context->CurrentWidth,
                       context->CurrentHeight,
                       path.TargetModeInfo.vSyncFreq.Numerator / path.TargetModeInfo.vSyncFreq.Denominator);
        }
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DISPLAY, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

_Use_decl_annotations_
NTSTATUS DisplayEvtAssignSwapChain(IDDCX_MONITOR monitor, const IDARG_IN_ASSIGN_SWAPCHAIN* args)
{
    UNREFERENCED_PARAMETER(monitor);

    TRACE_FUNCTION_ENTRY(TRACE_SWAPCHAIN);

    auto* context = reinterpret_cast<DisplayDeviceContext*>(args->pContext);

    TRACE_INFO(TRACE_SWAPCHAIN, "Assigning swap-chain (software processing)");

    // Tell IddCx we will process frames in software (no GPU acceleration)
    IDARG_IN_SWAPCHAINSETDEVICE setDevice = {};
    setDevice.pSwapChain = args->hSwapChain;
    setDevice.pDevice = nullptr; // Software processing

    NTSTATUS status = IddCxSwapChainSetDevice(&setDevice);
    if (!NT_SUCCESS(status))
    {
        TRACE_ERROR(TRACE_SWAPCHAIN, "IddCxSwapChainSetDevice failed: %!STATUS!", status);
        return status;
    }

    // Initialize swap-chain context
    context->SwapChainCtx.SwapChain = args->hSwapChain;
    context->SwapChainCtx.ShouldStop = FALSE;
    KeInitializeEvent(&context->SwapChainCtx.StopEvent, NotificationEvent, FALSE);

    TRACE_INFO(TRACE_SWAPCHAIN, "Creating present processing thread");

    // Create the present processing thread
    HANDLE threadHandle = nullptr;
    status = PsCreateSystemThread(&threadHandle,
                                  THREAD_ALL_ACCESS,
                                  nullptr,
                                  nullptr,
                                  nullptr,
                                  PresentProcessingThread,
                                  &context->SwapChainCtx);

    if (NT_SUCCESS(status))
    {
        // Convert thread handle to thread object
        status = ObReferenceObjectByHandle(threadHandle,
                                          THREAD_ALL_ACCESS,
                                          *PsThreadType,
                                          KernelMode,
                                          reinterpret_cast<PVOID*>(&context->SwapChainCtx.PresentThread),
                                          nullptr);
        ZwClose(threadHandle);

        if (!NT_SUCCESS(status))
        {
            TRACE_ERROR(TRACE_SWAPCHAIN, "ObReferenceObjectByHandle failed: %!STATUS!", status);
            // Failed to reference thread, signal stop and wait for thread to exit
            context->SwapChainCtx.ShouldStop = TRUE;
            KeSetEvent(&context->SwapChainCtx.StopEvent, IO_NO_INCREMENT, FALSE);
        }
        else
        {
            TRACE_INFO(TRACE_SWAPCHAIN, "Present processing thread created successfully");
        }
    }
    else
    {
        TRACE_ERROR(TRACE_SWAPCHAIN, "PsCreateSystemThread failed: %!STATUS!", status);
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_SWAPCHAIN, status);
    return status;
}

_Use_decl_annotations_
NTSTATUS DisplayEvtUnassignSwapChain(IDDCX_MONITOR monitor, const IDARG_IN_UNASSIGN_SWAPCHAIN* args)
{
    UNREFERENCED_PARAMETER(monitor);

    TRACE_FUNCTION_ENTRY(TRACE_SWAPCHAIN);

    auto* context = reinterpret_cast<DisplayDeviceContext*>(args->pContext);

    // Signal the present thread to stop
    if (context->SwapChainCtx.PresentThread != nullptr)
    {
        TRACE_INFO(TRACE_SWAPCHAIN, "Stopping present processing thread");

        context->SwapChainCtx.ShouldStop = TRUE;
        KeSetEvent(&context->SwapChainCtx.StopEvent, IO_NO_INCREMENT, FALSE);

        // Wait for the thread to terminate
        KeWaitForSingleObject(context->SwapChainCtx.PresentThread,
                             Executive,
                             KernelMode,
                             FALSE,
                             nullptr);

        TRACE_INFO(TRACE_SWAPCHAIN, "Present processing thread terminated");

        // Release the thread object reference
        ObDereferenceObject(context->SwapChainCtx.PresentThread);
        context->SwapChainCtx.PresentThread = nullptr;
    }

    // Clear swap-chain context
    context->SwapChainCtx.SwapChain = nullptr;

    TRACE_INFO(TRACE_SWAPCHAIN, "Swap-chain unassigned");
    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_SWAPCHAIN, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

_Use_decl_annotations_
NTSTATUS DisplayEvtD0Entry(WDFDEVICE device, WDF_POWER_DEVICE_STATE previousState)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);

    auto* context = GetDisplayContext(device);

    TRACE_INFO(TRACE_DEVICE, "Display device entering D0 (working state) from D%lu",
               previousState - WdfPowerDeviceD0);

    // Device is transitioning to working state
    // Resume display operations if coming from low-power state
    if (previousState == WdfPowerDeviceD3 || previousState == WdfPowerDeviceD3Final)
    {
        TRACE_INFO(TRACE_DEVICE, "Resuming display operations from powered-off state");

        // If there's an active swap-chain, resume present operations
        if (context->SwapChainCtx.SwapChain != nullptr && context->SwapChainCtx.PresentThread != nullptr)
        {
            TRACE_INFO(TRACE_DISPLAY, "Swap-chain present operations will resume automatically");
        }
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DEVICE, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

_Use_decl_annotations_
NTSTATUS DisplayEvtD0Exit(WDFDEVICE device, WDF_POWER_DEVICE_STATE targetState)
{
    TRACE_FUNCTION_ENTRY(TRACE_DEVICE);

    auto* context = GetDisplayContext(device);

    TRACE_INFO(TRACE_DEVICE, "Display device exiting D0 to D%lu state",
               targetState - WdfPowerDeviceD0);

    // Device is transitioning to low-power or off state
    if (targetState == WdfPowerDeviceD3 || targetState == WdfPowerDeviceD3Final)
    {
        TRACE_INFO(TRACE_DEVICE, "Suspending display operations for powered-off state");

        // Present thread will naturally pause when no new frames are available
        // The USB transport driver will handle stopping USB I/O
        // No explicit action needed here as the present loop is self-managing
    }

    TRACE_FUNCTION_EXIT_NTSTATUS(TRACE_DEVICE, STATUS_SUCCESS);
    return STATUS_SUCCESS;
}
